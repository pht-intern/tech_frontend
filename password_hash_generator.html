<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password Hash Generator</title>
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
            text-align: center;
        }

        .subtitle {
            color: #666;
            text-align: center;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
            font-size: 14px;
        }

        input[type="password"],
        input[type="text"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="password"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            font-weight: normal;
            cursor: pointer;
            user-select: none;
        }

        button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .result-group {
            margin-top: 30px;
        }

        .result-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .copy-btn {
            background: #4caf50;
            padding: 8px 16px;
            font-size: 14px;
            width: auto;
            margin: 0;
        }

        .copy-btn:hover {
            background: #45a049;
        }

        .copy-btn.copied {
            background: #2196F3;
        }

        textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            min-height: 100px;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .info-box {
            background: #f0f7ff;
            border-left: 4px solid #2196F3;
            padding: 12px 15px;
            margin-top: 20px;
            border-radius: 4px;
            font-size: 13px;
            color: #555;
        }

        .info-box strong {
            color: #2196F3;
        }

        .loading {
            display: none;
            text-align: center;
            color: #667eea;
            margin-top: 20px;
        }

        .loading.active {
            display: block;
        }

        .progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
            height: 25px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }

        .progress-text {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê Password Hash Generator</h1>
        <p class="subtitle">Generate Werkzeug-compatible scrypt password hashes</p>

        <form id="hashForm">
            <div class="form-group">
                <label for="password">Password:</label>
                <input type="password" id="password" name="password" placeholder="Enter password to hash" required>
                <div class="checkbox-group">
                    <input type="checkbox" id="showPassword">
                    <label for="showPassword">Show password</label>
                </div>
            </div>

            <button type="submit" id="generateBtn">Generate Hash</button>
            <div class="loading" id="loading">
                <p style="margin-bottom: 10px; font-weight: 600; color: #667eea;">Generating hash... This may take 10-30 seconds.</p>
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar">0%</div>
                </div>
                <p class="progress-text" id="progressText">Initializing...</p>
            </div>
        </form>

        <div class="result-group" id="passwordGroup" style="display: none;">
            <div class="result-label">
                <label for="passwordResult">Password Used:</label>
                <button type="button" class="copy-btn" id="copyPasswordBtn">Copy</button>
            </div>
            <textarea id="passwordResult" readonly></textarea>
        </div>

        <div class="result-group" id="resultGroup" style="display: none;">
            <div class="result-label">
                <label for="hashResult">Generated Hash:</label>
                <button type="button" class="copy-btn" id="copyBtn">Copy</button>
            </div>
            <textarea id="hashResult" readonly></textarea>
        </div>

        <div class="info-box">
            <strong>Format:</strong> scrypt:32768:8:1$[salt]$[hash]<br>
            <strong>Compatible with:</strong> Werkzeug's generate_password_hash() function<br>
            <strong>‚ö†Ô∏è Important:</strong> This tool prioritizes the backend API which uses Werkzeug directly for 100% accurate hash generation. Ensure your Flask backend server is running for best results. The generated hash will match exactly what Werkzeug produces, including correct salt and hash encoding.
        </div>
    </div>

    <!-- Scrypt library - using scrypt-js with proper loading -->
    <script>
    // Load scrypt-js and ensure it's available
    (function() {
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        // Try loading from multiple sources
        loadScript('https://unpkg.com/scrypt-js@3.0.1/scrypt.js')
            .catch(() => loadScript('https://cdn.jsdelivr.net/npm/scrypt-js@3.0.1/scrypt.js'))
            .catch(() => {
                console.error('Failed to load scrypt-js from all CDNs');
            });
    })();
    </script>
    <script>
        // Wait for scrypt library to load
        let scryptFunction = null;
        
        // scrypt-js exports the function in different ways depending on the build
        // The library might export as: scrypt, scryptJs, or through a factory function
        function getScryptFunction() {
            // Method 1: Direct global function (most common)
            if (typeof scrypt === 'function') {
                return scrypt;
            }
            
            // Method 2: scryptJs (alternative name)
            if (typeof scryptJs === 'function') {
                return scryptJs;
            }
            
            // Method 3: Object with scrypt property
            if (typeof scrypt === 'object' && scrypt !== null) {
                if (typeof scrypt.scrypt === 'function') {
                    return scrypt.scrypt;
                }
                if (typeof scrypt.default === 'function') {
                    return scrypt.default;
                }
                // Sometimes it's a factory that returns the function
                if (typeof scrypt === 'function') {
                    return scrypt;
                }
            }
            
            // Method 4: Window object
            if (typeof window !== 'undefined') {
                if (typeof window.scrypt === 'function') {
                    return window.scrypt;
                }
                if (typeof window.scryptJs === 'function') {
                    return window.scryptJs;
                }
                if (window.scrypt && typeof window.scrypt.scrypt === 'function') {
                    return window.scrypt.scrypt;
                }
            }
            
            // Method 5: Check if it's available as a module export
            if (typeof module !== 'undefined' && module.exports) {
                if (typeof module.exports === 'function') {
                    return module.exports;
                }
                if (module.exports.scrypt && typeof module.exports.scrypt === 'function') {
                    return module.exports.scrypt;
                }
            }
            
            // Method 6: Check for any global variable that might be scrypt
            for (let key in window) {
                if (key.toLowerCase().includes('scrypt') && typeof window[key] === 'function') {
                    return window[key];
                }
            }
            
            return null;
        }
        
        // Check if scrypt is available with retries
        function waitForScrypt() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 100; // 10 seconds max
                
                const checkScrypt = setInterval(() => {
                    attempts++;
                    scryptFunction = getScryptFunction();
                    
                    if (scryptFunction) {
                        clearInterval(checkScrypt);
                        console.log('Scrypt function loaded successfully');
                        resolve();
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkScrypt);
                        // Debug: log what's actually available
                        console.log('Window scrypt:', typeof window.scrypt, window.scrypt);
                        console.log('Global scrypt:', typeof scrypt, scrypt);
                        reject(new Error('Scrypt library failed to load. Please check the browser console for details.'));
                    }
                }, 100);
            });
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', async () => {
                try {
                    await waitForScrypt();
                } catch (e) {
                    console.error('Scrypt initialization error:', e);
                }
            });
        } else {
            // DOM already loaded
            (async () => {
                try {
                    await waitForScrypt();
                } catch (e) {
                    console.error('Scrypt initialization error:', e);
                }
            })();
        }

        // Show/hide password toggle
        document.getElementById('showPassword').addEventListener('change', function(e) {
            const passwordInput = document.getElementById('password');
            passwordInput.type = e.target.checked ? 'text' : 'password';
        });

        // Generate hash on form submit
        document.getElementById('hashForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const password = document.getElementById('password').value;
            const generateBtn = document.getElementById('generateBtn');
            const loading = document.getElementById('loading');
            const resultGroup = document.getElementById('resultGroup');
            const hashResult = document.getElementById('hashResult');
            const copyBtn = document.getElementById('copyBtn');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');

            if (!password) {
                alert('Please enter a password');
                return;
            }

            // Disable button and show loading
            generateBtn.disabled = true;
            loading.classList.add('active');
            resultGroup.style.display = 'none';
            const passwordGroup = document.getElementById('passwordGroup');
            if (passwordGroup) {
                passwordGroup.style.display = 'none';
            }
            
            // Show initial progress
            if (progressBar) {
                progressBar.style.width = '10%';
                progressBar.textContent = '10%';
            }
            if (progressText) {
                progressText.textContent = 'Connecting to server...';
            }

            try {
                // ALWAYS try to use backend API first (instant, accurate generation using Werkzeug)
                // This ensures the hash format matches exactly what Werkzeug generates
                try {
                    // Update progress
                    if (progressBar) {
                        progressBar.style.width = '50%';
                        progressBar.textContent = '50%';
                    }
                    if (progressText) {
                        progressText.textContent = 'Generating hash on server (using Werkzeug)...';
                    }
                    
                    const response = await fetch('/api/generate-password-hash', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ password: password })
                    });
                    
                    // Check if response is JSON before parsing
                    const contentType = response.headers.get("content-type");
                    const isJson = contentType && contentType.includes("application/json");
                    
                    if (response.ok) {
                        let data;
                        if (isJson) {
                            try {
                                data = await response.json();
                            } catch (jsonError) {
                                console.error("Failed to parse JSON response:", jsonError);
                                const textResponse = await response.text();
                                console.error("Response text:", textResponse.substring(0, 200));
                                if (progressText) {
                                    progressText.textContent = 'Error: Server returned invalid response.';
                                }
                                return;
                            }
                        } else {
                            // Non-JSON response (shouldn't happen for API endpoints)
                            const textResponse = await response.text();
                            console.error("Server returned non-JSON response:", textResponse.substring(0, 200));
                            if (progressText) {
                                progressText.textContent = 'Error: Server returned non-JSON response.';
                            }
                            return;
                        }
                        // Handle both JSONP and regular JSON responses
                        const responseData = data.data || data;
                        const hash = responseData.hash || data.hash;
                        
                        if (hash) {
                            // Success! Display results instantly
                            if (progressBar) {
                                progressBar.style.width = '100%';
                                progressBar.textContent = '100%';
                            }
                            if (progressText) {
                                progressText.textContent = 'Complete! Hash generated using Werkzeug.';
                            }
                            
                            // Use the hash directly from Werkzeug (guaranteed correct format)
                            hashResult.value = hash;
                            resultGroup.style.display = 'block';
                            copyBtn.classList.remove('copied');
                            copyBtn.textContent = 'Copy';
                            
                            // Display password
                            const passwordResult = document.getElementById('passwordResult');
                            const passwordGroup = document.getElementById('passwordGroup');
                            const copyPasswordBtn = document.getElementById('copyPasswordBtn');
                            if (passwordResult && passwordGroup && copyPasswordBtn) {
                                passwordResult.value = responseData.password || data.password || password;
                                passwordGroup.style.display = 'block';
                                copyPasswordBtn.classList.remove('copied');
                                copyPasswordBtn.textContent = 'Copy';
                            }
                            
                            // Hide loading after a brief moment
                            setTimeout(() => {
                                loading.classList.remove('active');
                            }, 500);
                            generateBtn.disabled = false;
                            return; // Exit early, we're done!
                        } else {
                            console.warn('Backend API response missing hash field:', data);
                            throw new Error('Backend response missing hash');
                        }
                    } else {
                        // API returned error, try to parse as JSON first
                        let errorData = {};
                        if (isJson) {
                            try {
                                errorData = await response.json();
                            } catch (jsonError) {
                                // If JSON parsing fails, try text
                                const errorText = await response.text();
                                console.error("Error response (text):", errorText.substring(0, 200));
                            }
                        } else {
                            // Non-JSON error response
                            const errorText = await response.text();
                            console.error("Non-JSON error response:", errorText.substring(0, 200));
                        }
                        try {
                            errorData = JSON.parse(errorText);
                        } catch (e) {
                            errorData = { message: errorText };
                        }
                        console.warn('Backend API error, falling back to client-side generation:', errorData);
                        throw new Error(errorData.message || 'Backend API error');
                    }
                } catch (apiError) {
                    console.warn('Backend API not available or failed, using client-side generation:', apiError);
                    if (progressText) {
                        progressText.textContent = 'Backend unavailable. Using client-side generation (slower, may take 10-30 seconds)...';
                    }
                    // Fall through to client-side generation
                }
                
                // If API failed, use client-side generation (slower but works offline)
                if (progressText) {
                    progressText.textContent = 'Using client-side generation (this may take 10-30 seconds)...';
                }
                // Ensure scrypt library is loaded
                if (!scryptFunction) {
                    await waitForScrypt();
                }
                
                if (!scryptFunction) {
                    // Last attempt: try to find scrypt in any way possible
                    console.log('Attempting to find scrypt function...');
                    console.log('typeof scrypt:', typeof scrypt);
                    console.log('window.scrypt:', window.scrypt);
                    console.log('Available window properties with "scrypt":', 
                        Object.keys(window).filter(k => k.toLowerCase().includes('scrypt')));
                    
                    // Try to access it directly one more time
                    scryptFunction = getScryptFunction();
                    
                    if (!scryptFunction) {
                        throw new Error('Scrypt library is not available. The library may need to be loaded differently. Please check the browser console for details.');
                    }
                }
                // Generate salt (16 bytes, base64 encoded)
                const saltBytes = new Uint8Array(16);
                crypto.getRandomValues(saltBytes);
                const saltBase64 = btoa(String.fromCharCode(...saltBytes))
                    .replace(/\+/g, '.')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');

                // Convert password to bytes
                const passwordBytes = new TextEncoder().encode(password);
                
                // Convert salt from base64 back to bytes for scrypt
                const saltStr = atob(saltBase64.replace(/\./g, '+').replace(/_/g, '/'));
                const saltArray = new Uint8Array(saltStr.length);
                for (let i = 0; i < saltStr.length; i++) {
                    saltArray[i] = saltStr.charCodeAt(i);
                }

                // Scrypt parameters matching Werkzeug: N=32768, r=8, p=1
                const N = 32768;  // CPU/memory cost parameter
                const r = 8;      // Block size parameter
                const p = 1;      // Parallelization parameter
                const dkLen = 64; // Derived key length (64 bytes = 512 bits) - Werkzeug uses 64 bytes, not 32!

                // Note: progressBar and progressText are already declared at the top of the function
                
                // Perform scrypt hashing with progress updates
                // scrypt-js uses a callback-based API
                // Callback signature: callback(error, progress, key)
                // - error: Error object if an error occurred (null/undefined otherwise)
                // - progress: Number between 0 and 1 for progress updates
                // - key: Uint8Array with the derived key when complete
                const hashBytes = await new Promise((resolve, reject) => {
                    try {
                        scryptFunction(passwordBytes, saltArray, N, r, p, dkLen, function(error, progress, key) {
                            // Check for actual error - only reject if it's an Error object, not a number
                            if (error instanceof Error) {
                                reject(error);
                                return;
                            }
                            
                            // Check if we have the final key (completion)
                            if (key !== undefined && key !== null) {
                                // Key should be a Uint8Array of the correct length
                                if (key instanceof Uint8Array && key.length === dkLen) {
                                    resolve(key);
                                    return;
                                }
                                // Try to convert if it's array-like
                                if (Array.isArray(key) && key.length === dkLen) {
                                    resolve(new Uint8Array(key));
                                    return;
                                }
                            }
                            
                            // Handle progress updates
                            // Progress can be passed as first parameter (error position) or second parameter
                            let actualProgress = null;
                            
                            if (typeof error === 'number' && error >= 0 && error <= 1) {
                                // First parameter is actually progress
                                actualProgress = error;
                            } else if (typeof progress === 'number' && progress >= 0 && progress <= 1) {
                                // Second parameter is progress
                                actualProgress = progress;
                            }
                            
                            if (actualProgress !== null) {
                                // Update progress bar
                                const percentage = Math.min(100, Math.max(0, Math.round(actualProgress * 100)));
                                progressBar.style.width = percentage + '%';
                                progressBar.textContent = percentage + '%';
                                
                                if (percentage < 10) {
                                    progressText.textContent = 'Starting computation...';
                                } else if (percentage < 30) {
                                    progressText.textContent = 'Computing hash (this is normal, please wait)...';
                                } else if (percentage < 60) {
                                    progressText.textContent = 'Processing... ' + percentage + '% complete';
                                } else if (percentage < 90) {
                                    progressText.textContent = 'Almost done... ' + percentage + '% complete';
                                } else {
                                    progressText.textContent = 'Finalizing... ' + percentage + '% complete';
                                }
                            }
                        });
                    } catch (err) {
                        reject(err);
                    }
                });

                // Convert hash to hex
                const hashHex = Array.from(hashBytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');

                // Format as Werkzeug scrypt hash: scrypt:32768:8:1$salt$hash
                const hashString = `scrypt:32768:8:1$${saltBase64}$${hashHex}`;

                // Display results
                hashResult.value = hashString;
                resultGroup.style.display = 'block';
                copyBtn.classList.remove('copied');
                copyBtn.textContent = 'Copy';
                
                // Display password
                const passwordResult = document.getElementById('passwordResult');
                const passwordGroup = document.getElementById('passwordGroup');
                const copyPasswordBtn = document.getElementById('copyPasswordBtn');
                if (passwordResult && passwordGroup && copyPasswordBtn) {
                    passwordResult.value = password;
                    passwordGroup.style.display = 'block';
                    copyPasswordBtn.classList.remove('copied');
                    copyPasswordBtn.textContent = 'Copy';
                }

            } catch (error) {
                console.error('Error generating hash:', error);
                const errorMessage = error && error.message ? error.message : (error ? String(error) : 'Unknown error');
                alert('Error generating hash: ' + errorMessage);
            } finally {
                generateBtn.disabled = false;
                loading.classList.remove('active');
                // Reset progress bar (using variables declared at top of function)
                if (progressBar) {
                    progressBar.style.width = '0%';
                    progressBar.textContent = '0%';
                }
                if (progressText) {
                    progressText.textContent = 'Initializing...';
                }
            }
        });

        // Copy hash to clipboard
        document.getElementById('copyBtn').addEventListener('click', function() {
            const hashResult = document.getElementById('hashResult');
            hashResult.select();
            hashResult.setSelectionRange(0, 99999); // For mobile devices

            try {
                document.execCommand('copy');
                const copyBtn = document.getElementById('copyBtn');
                copyBtn.textContent = 'Copied!';
                copyBtn.classList.add('copied');
                
                setTimeout(() => {
                    copyBtn.textContent = 'Copy';
                    copyBtn.classList.remove('copied');
                }, 2000);
            } catch (err) {
                alert('Failed to copy. Please select and copy manually.');
            }
        });

        // Copy password to clipboard
        document.getElementById('copyPasswordBtn').addEventListener('click', function() {
            const passwordResult = document.getElementById('passwordResult');
            passwordResult.select();
            passwordResult.setSelectionRange(0, 99999); // For mobile devices

            try {
                document.execCommand('copy');
                const copyPasswordBtn = document.getElementById('copyPasswordBtn');
                copyPasswordBtn.textContent = 'Copied!';
                copyPasswordBtn.classList.add('copied');
                
                setTimeout(() => {
                    copyPasswordBtn.textContent = 'Copy';
                    copyPasswordBtn.classList.remove('copied');
                }, 2000);
            } catch (err) {
                alert('Failed to copy. Please select and copy manually.');
            }
        });
    </script>
</body>
</html>

